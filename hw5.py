#import json
import numpy as np
import matplotlib.pyplot as plt
from typing import Tuple, Union
import pathlib
import pandas as pd
import math

class QuestionnaireAnalysis:
    """
    Reads and analyzes data generated by the questionnaire experiment.
    Should be able to accept strings and pathlib.Path objects.
    """



    def __init__(self, data_fname: Union[pathlib.Path, str]):
        
        if isinstance(data_fname, str):
            self.data_fname = pathlib.Path(data_fname)
        else:

            self.data_fname = data_fname
            
        if not self.data_fname.exists():
            raise ValueError("File not found.")
  
        self.data = None
        # ...

    def read_data(self):
        """Reads the json data located in self.data_fname into memory, to
        the attribute self.data.
        """
    
        
        df = pd.read_json(self.data_fname)
        self.data = df
        #return df

    def show_age_distrib(self) -> Tuple[np.ndarray, np.ndarray]:
        """Calculates and plots the age distribution of the participants.

        Returns
        -------
        hist : np.ndarray
            Number of people in a given bin
        bins : np.ndarray
            Bin edges
        """
        df = self.data
        ages = df['age']
        bins = np.arange(0, 101, 10)
        hist, bins = np.histogram(ages, bins=bins)
        plt.hist(ages, bins=bins)
        plt.xlabel('Age')
        plt.ylabel('Count')
        plt.title('Age Distribution')
        plt.show()
        return hist, bins
        
    def is_email_valid(self, email) -> bool:
        find_at = email.find("@")
        if email[find_at + 1] == ".":
            return False
        elif email.count("@") != 1 or email.startswith("@") or email.endswith("@"):
            return False
        elif email.count(".") < 1 or email.startswith(".") or email.endswith("."):
            return False
        return True
    
    def remove_rows_without_mail(self) -> pd.DataFrame:
        """Checks self.data for rows with invalid emails, and removes them.
        Returns
        -------
        df : pd.DataFrame
          A corrected DataFrame, i.e. the same table but with the erroneous rows removed and
          the (ordinal) index after a reset.
            """
        df = self.data
        email = df['email']
        invalid_indices = []
        for i, element in enumerate(email):
            if not self.is_email_valid(element):
                invalid_indices.append(i)
        new_df = df.drop(invalid_indices).reset_index(drop=True)
        return new_df
    
    def fill_na_with_mean(self) -> Tuple[pd.DataFrame, np.ndarray]:
        self.read_data()
        df = self.data
        columns_to_fill = df.iloc[:,[7, 8, 9, 10,11]]
        missing_rows = columns_to_fill.isnull().any(axis=1).astype(bool)
        corrected_indices = np.where(missing_rows)[0]
        n = columns_to_fill.transpose().fillna(columns_to_fill.mean(axis=1)).transpose()
        new_df = df.copy()
        new_df.iloc[:, -5:] = n.iloc[:, :]
                              
        return new_df, corrected_indices
      
    
    def score_subjects(self, maximal_nans_per_sub: int = 1) -> pd.DataFrame:
        self.read_data()
        df = self.data.copy()
        #nan_counts = df.iloc[:, -5:]
        nan_counts = df.iloc[:, -5:].isna().sum(axis=1)
        df_2 = df.iloc[:, -5:].mean(axis=1)
        df_2 = df_2.apply(np.floor)
        df_2 = df_2.astype('UInt8')
        new_df = pd.concat([df, df_2], axis=1)
        new_df.rename(columns={0: "score"}, inplace=True)
        new_df.loc[nan_counts > maximal_nans_per_sub, 'score'] = np.nan
  
        return new_df
        
    def correlate_gender_age(self) -> pd.DataFrame:
        self.read_data()
        df = self.data.copy()
        #df['age'].fillna(-1, inplace=True)
        # Create a MultiIndex with three levels: ordinal index, gender, and age
        df.set_index(['gender', 'age'], append=True, inplace=True)
        df = df.reorder_levels([df.index.name, 'gender', 'age'])
        age_values = df.index.get_level_values('age')
        df = df[pd.notnull(age_values)]
        # Allocate subjects into groups based on gender and age
       
        groups = df.groupby(['gender', df.index.get_level_values('age') > 40]).mean()

        # Calculate the average result per question per group
        groups = groups.drop('id', axis=1)
        groups.index.set_names('age', level=1, inplace=True)
        result_df = groups

        return result_df
 
# analysis = QuestionnaireAnalysis(pathlib.Path('data.json'))
# a=  analysis.correlate_gender_age()
