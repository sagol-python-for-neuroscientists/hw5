import pathlib
import json
from typing import *
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import re
from statistics import mean
import itertools

def valid_mail(mail):
    """
    receive string and return True of it's validate mail adress and False otherwise
    """
    regex = '^\w+([\.-]?\w+)@\w+([\.-]?\w+)(\.\w{1,3})+$'
    if (re.search(regex, mail)):
        return True
    else:
        return False

class QuestionnaireAnalysis:
    """
    Reads and analyzes data generated by the questionnaire experiment.
    Should be able to accept strings and pathlib.Path objects.
    """

    def __init__(self, data_fname: Union[pathlib.Path, str]):
        if isinstance(data_fname, str):
            self.data_fname=pathlib.Path(data_fname)
        else:
            self.data_fname=data_fname
        if not self.data_fname.exists():
            raise ValueError("could not find file")
        self.data=None

    def read_data(self):
        with self.data_fname.open() as f:
            self.data=pd.DataFrame(json.load(f))

    def show_age_distrib(self) -> Tuple[np.ndarray, np.ndarray]:
        """Calculates and plots the age distribution of the participants.
    Returns
    -------
    hist : np.ndarray
      Number of people in a given bin
    bins : np.ndarray
      Bin edges
        """
        ages = list(self.data["age"])
        ages = [item for item in ages if item != "nan"]
        n, bins, _ = plt.hist(ages, bins=np.arange(0,110,10))
        return n, bins

    def remove_rows_without_mail(self) -> pd.DataFrame:
        """Checks self.data for rows with invalid emails, and removes them.

    Returns
    -------
    df : pd.DataFrame
      A corrected DataFrame, i.e. the same table but with the erroneous rows removed and
      the (ordinal) index after a reset.
        """
        return self.data[self.data.email.apply(valid_mail)].reset_index()

    def fill_na_with_mean(self) -> Tuple[pd.DataFrame, np.ndarray]:
        """Finds, in the original DataFrame, the subjects that didn't answer
        all questions, and replaces that missing value with the mean of the
        other grades for that student.

    Returns
    -------
    df : pd.DataFrame
      The corrected DataFrame after insertion of the mean grade
    arr : np.ndarray
          Row indices of the students that their new grades were generated
        """
        q1_avg = mean([item for item in self.data["q1"] if item != "nan"])
        q2_avg = mean([item for item in self.data["q2"] if item != "nan"])
        q3_avg = mean([item for item in self.data["q3"] if item != "nan"])
        q4_avg = mean([item for item in self.data["q4"] if item != "nan"])
        q5_avg = mean([item for item in self.data["q5"] if item != "nan"])
        replaced=[]
        replaced.append(self.data.index[self.data['q1']== "nan"].tolist())
        replaced.append(self.data.index[self.data['q2']== "nan"].tolist())
        replaced.append(self.data.index[self.data['q3']== "nan"].tolist())
        replaced.append(self.data.index[self.data['q4']== "nan"].tolist())
        replaced.append(self.data.index[self.data['q5']== "nan"].tolist())
        df = self.data.copy()
        df.q1.replace("nan",q1_avg )
        df.q2.replace("nan", q2_avg, inplace=True)
        df.q3.replace("nan", q3_avg, inplace=True)
        df.q4.replace("nan", q4_avg, inplace=True)
        df.q5.replace("nan", q5_avg, inplace=True)
        replaced =list(set(list(itertools.chain.from_iterable(replaced))))
        replaced.sort()
        return df, np.array(replaced)

    def score_subjects(self, maximal_nans_per_sub: int = 1) -> pd.DataFrame:
        replaced=[]
        replaced.append(self.data.index[self.data['q1']== "nan"].tolist())
        replaced.append(self.data.index[self.data['q2']== "nan"].tolist())
        replaced.append(self.data.index[self.data['q3']== "nan"].tolist())
        replaced.append(self.data.index[self.data['q4']== "nan"].tolist())
        replaced.append(self.data.index[self.data['q5']== "nan"].tolist())
        replaced=list(itertools.chain.from_iterable(replaced))
        cand_nan=list(set([x for x in replaced if replaced.count(x) > maximal_nans_per_sub]))
        df=self.data.iloc[:,7:12]
        df.replace("nan", np.nan, inplace=True)
        new=self.data.copy()
        new["score"]=df.mean(axis=1)
        new["score"] = new["score"].astype("uint8")
        for i in cand_nan:
            new.loc[i, 'score']=""
        new.replace("", np.nan, inplace=True)
        new["score"] = new["score"].astype("UInt8")
        return new

    def correlate_gender_age(self) -> pd.DataFrame:
        """Looks for a correlation between the gender of the subject, their age
        and the score for all five questions.

    Returns
    -------
    pd.DataFrame
        A DataFrame with a MultiIndex containing the gender and whether the subject is above
        40 years of age, and the average score in each of the five questions.
    """
        df = self.data
        df.replace("nan", np.nan, inplace=True)
        df["age"]=df["age"]>40
        df = df.drop(['id'], axis=1)
        return df.groupby(['gender', 'age']).mean()

