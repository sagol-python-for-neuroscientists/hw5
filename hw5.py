import numpy as np
import pandas as pd
import pathlib
import matplotlib.pyplot as plt
from typing import Union, Tuple


class QuestionnaireAnalysis:
    """
    Reads and analyzes data generated by the questionnaire experiment.
    Should be able to accept strings and pathlib.Path objects.
    """

    def __init__(self, data_fname: Union[pathlib.Path, str]):
        try:
            self.data_fname = pathlib.Path(data_fname).resolve()
        except TypeError:
            print('file name must be a string or a pathlib path')
            raise
        if not self.data_fname.is_file():
            raise ValueError('file does not exist, please recheck')


    def read_data(self):
        """Reads the json data located in self.data_fname into memory, to
        the attribute self.data.
        """
        self.data = pd.read_json(self.data_fname)
        return self.data

#A1
    def show_age_distrib(self) -> Tuple[np.ndarray, np.ndarray]:
       """Calculates and plots the age distribution of the participants.
    Returns
    -------
    hist : np.ndarray
     Number of people in a given bin
    bins : np.ndarray
     Bin edges
       """
       _, ax = plt.subplots()
       bin_cnt, edges, _ = ax.hist(self.data['age'], bins=np.arange(0, 110, 10))
       ax.set_xlabel('Age')
       ax.set_ylabel('Counts')
       ax.set_title('Age Distribution')
       #plt.show()
       return bin_cnt, edges
        
#A2
    def remove_rows_without_mail(self) -> pd.DataFrame:
        """Checks self.data for rows with invalid emails, and removes them.
    Returns
    -------
    df : pd.DataFrame
     A corrected DataFrame, i.e. the same table but with the erroneous rows removed and
    the (ordinal) index after a reset.
    """
        regex = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9-]+\.[A-Z|a-z]{1,}\b' #Actually the first hit on google, and it works perefct.
        is_valid_email = self.data['email'].str.match(regex)
        corrected_df = self.data[is_valid_email].reset_index(drop=True)
        return corrected_df

#A3
    def fill_na_with_mean(self) -> Tuple[pd.DataFrame, np.ndarray]:
       """Finds, in the original DataFrame, the subjects that didn't answer
       all questions, and replaces that missing value with the mean of the
       other grades for that student.

   Returns
   -------
   df : pd.DataFrame
     The corrected DataFrame after insertion of the mean grade
   arr : np.ndarray
         Row indices of the students that their new grades were generated
       """
       df = self.data.copy()
       grade_avg = df.loc[:,"q1":"q5"].mean(axis=1) #Get the mean grade for each student
       nan_idx = df.loc[:, "q1":"q5"].isnull().any(axis=1).to_numpy().nonzero()[0] #get the indexes for the null values
       df.loc[nan_idx, "q1":"q5"] = pd.DataFrame(grade_avg.iloc[nan_idx].values.reshape(-1, 1)) #Replace the null values wit the means
       return df, nan_idx


#A4
    def score_subjects(self, maximal_nans_per_sub: int = 1) -> pd.DataFrame:
       """Calculates the average score of a subject and adds a new "score" column
       with it.

       If the subject has more than "maximal_nans_per_sub" NaN in his grades, the
       score should be NA. Otherwise, the score is simply the mean of the other grades.
       The datatype of score is UInt8, and the floating point raw numbers should be
       rounded down.

       Parameters
       ----------
       maximal_nans_per_sub : int, optional
           Number of allowed NaNs per subject before giving a NA score.

       Returns
       -------
       pd.DataFrame
           A new DF with a new column - "score".
       """
       
       new_df = self.data.copy() #Let's make sure we don't change the og data
       nan_sum = new_df.loc[:, "q1":"q5"].isnull().sum(1)  #find and sum all the nans
       new_df['score'] = new_df.loc[:, "q1":"q5"].mean(1).apply(np.floor).astype('UInt8') #create new column with avg score.
       new_df.loc[nan_sum>maximal_nans_per_sub, 'score'] = np.nan #turn the score for anybody over the nan threshold to nan
       return new_df
 

        
       
#Bonus
    def correlate_gender_age(self) -> pd.DataFrame:
       """Looks for a correlation between the gender of the subject, their age
       and the score for all five questions.


   Returns
   -------
   pd.DataFrame
       A DataFrame with a MultiIndex containing the gender and whether the subject is above
       40 years of age, and the average score in each of the five questions.
   """
       age_df=self.data[self.data['age'].notna()] #remove NaN into new df
       age_df['age'] = np.where(age_df['age']>40, True, False) #define age as <40<
       age_df=age_df.set_index(['gender','age']) #make into multiIndex
       mean_score = age_df.groupby(['gender','age'])[["q1","q2","q3","q4","q5"]].mean()
       return(mean_score)


